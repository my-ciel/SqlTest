Chapter 2 : Query 최적화의 기본 사항 
###################################################################################### 
# TEST 1 : SQL 진단 도구 1
###################################################################################### 

1. EXPLAIN PLAN FOR 실행 후 Plan_table을 조회합니다. 
EXPLAIN PLAN FOR
SELECT employee_id, last_name, first_name, department_name 
from employees e JOIN departments d 
ON e.department_id = d.department_id 
and last_name like 'T%' 
ORDER BY last_name;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'TYPICAL'));


2. V$SQL과 V$SQL_PLAN 뷰를 활용하여 최근에 실행된 커서에 대한 실행 계획을 검사해 봅니다. 
SELECT employee_id, last_name, first_name, department_name 
from employees e JOIN departments d 
ON e.department_id = d.department_id 
and last_name like 'T%' 
ORDER BY last_name;

SELECT sql_text, hash_value, address
FROM v$sql
WHERE sql_text LIKE 'SELECT employee_id%' ;


SELECT id
     , lpad (' ', depth) || operation operation
     , options , object_name , optimizer , cost
FROM V$SQL_PLAN
WHERE hash_value = 1700806449
AND address    = '00007FF9A7402188'
START WITH id = 0
CONNECT BY
       (     prior id           = parent_id
         AND prior hash_value   = hash_value
         AND prior child_number = child_number
       )
ORDER SIBLINGS BY id, position;

3.DBMS_XPLAN.DISPLAY와 DBMS_XPLAN.DISPLAY_CURSOR 를 비교해 봅니다.

EXEC DBMS_STATS.GATHER_TABLE_STATS ('c##hr','employees');
EXEC DBMS_STATS.GATHER_TABLE_STATS ('c##hr','departments');

SELECT *
FROM   employees JOIN departments
ON   (e.department_id = d.department_id)
WHERE e.email='SSTILES' OR d.department_name='Treasury';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(NULL, NULL, 'TIPYCAL'));
--DBMS_XPLAN.DISPLAY([plan_table_name], [statement_id], [format]) 
--Plan_Table의 가장 최근 SQL에대해 기본 형식으로 출력

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR);

------------------------------------------------------------------------------------------------

alter system flush buffer_cache;
alter system flush shared_pool;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR);

4. SQLPlus Autotrace
--CMD에서 sqlplus c##hr/oracle실행
set autotrace traceonly
SELECT *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
AND e.email='SSTILES' OR d.department_name='Treasury';

###################################################################################### 
# TEST 2 : SQL 진단 도구 2
###################################################################################### 
1. 다음과 같이 SQL_TRACE를 세션레벨에서 활성화하고 SQL 명령을 실행합니다.
show parameter sql_trace
ALTER SESSION SET sql_trace=TRUE;
ALTER SYSTEM FLUSH shared_pool;
ALTER SYSTEM FLUSH buffer_cache;

SELECT employee_id, last_name, department_name
FROM employees JOIN departments
USING (department_id);

ALTER SESSION SET sql_trace=FALSE;

2. 현재 세션에 대한 서버프로세스 정보 및 생성된 추적파일의 경로와 이름을 알아봅니다.
SELECT p.spid
FROM   v$process p
JOIN   v$session s ON p.addr = s.paddr
WHERE s.username = 'C##HR';

SELECT value FROM v$diag_info
WHERE name = 'Default Trace File';

3. 탐색기에서 해당 경로로 이동 후 터미널에서 다음을 실행합니다. 
tkprof xe_ora_34392.trc mytrc.txt sys=no waits=yes

mytrc.txt 파일을 확인합니다.

###################################################################################### 
# TEST 3 : 객체 통계 관리 TEST 
###################################################################################### 
1. 다음 명령으로 객체통계를 조회해 봅니다.
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables;

2. 만약 통계데이터가 있다면 다음을 실행하여 모든 통계를 삭제합니다.
EXEC dbms_stats.delete_schema_stats('c##hr');
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables;

3. ANALYZE 명령으로 개별 객체의 통계를 생성합니다. 
ANALYZE TABLE employees COMPUTE STATISTICS;
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables;
ANALYZE TABLE employees DELETE STATISTICS;

4. DBMS_STATS로 개별 테이블의 객체 통계를 생성합니다.
EXEC dbms_stats.gather_table_stats('c##hr','employees');
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables;
EXEC dbms_stats.delete_table_stats('c##hr','employees');

5. DBMS_STATS로 스키마의 모든 객체의 통계를 생성합니다.
EXEC dbms_stats.gather_schema_stats('c##hr');
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables;

6. 실습을 위해 TESTEMP 테이블을 생성합니다.
CREATE TABLE testemp
AS 
SELECT * FROM employees;

7. 생성한 테이블을 분석하여 테이블의 실제 행수와 분석결과를 비교해 봅니다.
EXEC dbms_stats.gather_table_stats('c##hr','TEST');
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';

SELECT COUNT(*) FROM testemp;

8. 다음 INSERT문을 반복실행하여 테이블의 행 수가 6000건 이상 되도록 데이터를 입력합니다.
INSERT INTO testemp
SELECT * FROM testemp;
commit;

9. 생성한 테이블의 행 수와 테이블 통계데이터를 비교해 봅니다. 
SELECT COUNT(*) FROM testemp;
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';

10. 테이블의 통계를 다시 생성하고 확인합니다. 
EXEC dbms_stats.gather_table_stats('c##hr','TESTEMP');
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';

11. 테이블에 대량의 데이터 삭제를 삭제한 후 분석 전,후의 통계값을 확인합니다.
DELETE FROM testemp
WHERE department_id IN (50, 60, 80);
COMMIT;
SELECT COUNT(*) FROM testemp;
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';
ANALYZE TABLE testemp COMPUTE STATISTICS;
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';

12. 삭제된 행이 많은 테이블의 HWM을 조정하기 위해 테이블 재구성을 수행합니다.
ALTER TABLE testemp ENABLE ROW MOVEMENT;
ALTER TABLE testemp SHRINK SPACE;
ALTER TABLE testemp DISABLE ROW MOVEMENT;

ANALYZE TABLE testemp COMPUTE STATISTICS;
SELECT table_name, num_rows, blocks, empty_blocks, 
       TO_CHAR(last_analyzed,'yy/mm/dd hh24:mi:ss') last_analyzed
FROM user_tables
WHERE table_name = 'TESTEMP';

13. 실습을 정리합니다.
DROP TABLE testemp PURGE;

###################################################################################### 
# TEST 4 : 열통계와 히스토그램 
###################################################################################### 
1. 실습에 사용할 테이블을 생성합니다.
CREATE SEQUENCE member_id_seq ;
CREATE TABLE member( memb_id NUMBER , age NUMBER( 2 ) ) ;
EXEC dbms_random.seed( 0 ) ;

insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(1,19)  from dual connect by level <= 50;
insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(20,29) from dual connect by level <= 270;
insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(30,39) from dual connect by level <= 330;
insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(41,49) from dual connect by level <= 200;
insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(50,59) from dual connect by level <= 100;
insert into member(memb_id, age)
select member_id_seq.nextval, dbms_random.value(60,99) from dual connect by level <= 50;
--popular value
insert into member(memb_id, age)
select member_id_seq.nextval, 40 from dual connect by level <= 1000; 
COMMIT;

2. 나이별 인원 수를 집계합니다.  
SELECT age,
       COUNT(*) AS cnt
FROM   member
GROUP  BY age;

3. AGE 열에 인덱스를 생성한 후 히스토그램 생성 옵션과 함께 테이블 통계를 생성합니다.
CREATE INDEX member_age_idx ON member(age);

exec DBMS_STATS.GATHER_TABLE_STATS('C##HR', 'MEMBER', METHOD_OPT => 'FOR COLUMNS AGE SIZE 1');

4. 정보가 유독 많은 데이터를 검색한 후 실행계획을 확인합니다. 
추가로, 히스토그램의 버킷수도 확인합니다.
EXPLAIN PLAN FOR
SELECT * FROM member WHERE age = 40;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

SELECT num_distinct, num_buckets,histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'MEMBER'
AND    column_name = 'AGE' ;


5. 히스토그램의 버킷수를 조정한 후 버킷 수를 확인합니다.

exec DBMS_STATS.GATHER_TABLE_STATS('C##HR', 'MEMBER', METHOD_OPT => 'FOR COLUMNS AGE SIZE 100');
SELECT num_distinct, num_buckets,histogram
FROM   user_tab_col_statistics
WHERE  table_name = 'MEMBER'
AND    column_name = 'AGE' ;


6. 다시 데이터를 검색한 후 실행계획을 확인합니다.
EXPLAIN PLAN FOR
SELECT * FROM member WHERE age = 40;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

7. USER_HISTOGRAM을 통해 AGE 히스토그램의 누적 정보를 확인할 수도 있습니다.

SELECT endpoint_value, endpoint_number
FROM   user_histograms
WHERE  table_name = 'MEMBER'
AND    column_name = 'AGE';

endpoint_value : 버킷에 할당된 컬럼 값
endpoint_number : endpoint_value로 정렬했을 때, 최소 값부터 현재 값까지의 누적수량
endpoint_number가 누적수량을 의미하므로 바로 앞 endpoint_value까지의 누적수량을 차감함으로써 해당 버킷의 값 빈도수를 알 수 있습니다.

8. 실습을 정리합니다.
DROP TABLE member PURGE;


###################################################################################### 
# TEST 5 : Query Transformer Test 
###################################################################################### 
다음은 쿼리 변환기가 OR을 사용하는 입력 쿼리를 UNION ALL을 사용하는 출력 쿼리로 다시 작성하는 과정을 보여줍니다.
1. 다음 명령을 실행한 후 실행계획을 확인해 봅니다. 
ALTER SYSTEM FLUSH shared_pool;
EXPLAIN PLAN FOR
SELECT *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
AND e.email='SSTILES' OR d.department_name='Treasury';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

2. WHERE절에 사용된 두 열에 인덱스를 생성합니다.
CREATE INDEX emp_email_idx ON employees(email);
CREATE INDEX dept_dname_idx ON departments(department_name);

SELECT table_name, index_name
FROM user_indexes
WHERE table_name IN ('EMPLOYEES', 'DEPARTMENTS');

3. 다시 한번 SELECT 문을 실행한 후 SQL Developer의 "계획설명"을 통해 실행계획을 확인해 봅니다. 
ALTER SYSTEM FLUSH shared_pool;
EXPLAIN PLAN FOR
SELECT *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
AND e.email='SSTILES' OR d.department_name='Treasury';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

실행계획에서는 UNION ALL이 포함된 두 개의 쿼리 블록으로 나뉘어 처리되고 있습니다. 
하나는 d.department_name = 'Treasury' 조건에 최적화되어 DEPARTMENTS 인덱스를 타고 접근, 
다른 하나는 e.email = 'SSTILES' 조건에 최적화되어 EMPLOYEES 인덱스를 타고 접근합니다.
이러한 구조는 Oracle 옵티마이저가 OR 조건을 효율적으로 처리하기 위해 내부적으로 쿼리를 
UNION ALL로 분해하는 "OR-expansion" 최적화를 수행한 결과입니다.

--만약 UNION ALL로 쿼리변환이 일어나지 않았다면 다음과 같이 명시적으로 OR 조건 분해를 유도하는 힌트를 줄 수 있습니다.
ALTER SYSTEM FLUSH shared_pool;
EXPLAIN PLAN FOR
SELECT /*+ OR_EXPAND */ *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
WHERE e.email='SSTILES' OR d.department_name='Treasury';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);

4. 인덱스를 삭제하여 실습을 정리합니다.
DROP INDEX emp_email_idx;
DROP INDEX dept_dname_idx;


###################################################################################### 
# TEST 6 : Optimizer Mode와 실행계획 
###################################################################################### 
1. 현재 Optimizer Mode의 설정값을 확인합니다. 초기 값은 ALL_ROWS 입니다.
show parameter optimizer_mode 

2. 다음 명령문의 실행계획을 확인합니다. 
ALTER SYSTEM FLUSH shared_pool;
SELECT *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
AND e.email='SSTILES' OR d.department_name='Treasury';

3. Optimizer Mode를 세션레벨에서 FIRST_ROWS_1로 변경합니다.
ALTER SESSION SET optimizer_mode=first_rows_1;

4. 이전에 실행한 명령문의 실행계획을 다시 확인합니다. 
ALTER SYSTEM FLUSH shared_pool;
SELECT *
FROM   employees e JOIN departments d
ON  (e.department_id = d.department_id)
AND e.email='SSTILES' OR d.department_name='Treasury';

5. 최적화 모드를 다시 ALL_ROWS로 수정하고 실습에 사용한 인덱스를 삭제하여 실습을 초기화 합니다. 
ALTER SESSION SET optimizer_mode=all_rows;
DROP INDEX emp_email_idx;
DROP INDEX dept_dname_idx;

6. optimizer_dynamic_sampling  파라미터는 옵티마이저가 통계가 부족하거나 부정확한 경우, 실행 시점에 동적으로 샘플링하여 통계정보를 수집하게 해줍니다. SQL을 파싱(parsing)할 때 옵티마이저가 더 나은 실행계획을 만들기 위해 자동으로 데이터를 일부 읽어 분석합니다. 0~10으로 설정 가능하며 0은 동적 샘플링을 하지 않고 1은 최소한의 샘플링을 합니다. 2에서 10으로 갈 수록 점점 더 많은 양의 샘플링을 수행하며 기본값은 2입니다. 
show parameter optimizer_dynamic_sampling

###################################################################### 
# TEST 7 : 옵티마이저 힌트TEST
######################################################################
1. 다음과 같이 사이즈가 큰 테이블(BIGEMP)를 생성합니다.

--테이블생성
CREATE TABLE bigemp AS SELECT * FROM employees;
--데이터증가
BEGIN
  FOR i IN 1..12 LOOP 
    INSERT INTO bigemp SELECT * FROM bigemp;
  END LOOP;
  COMMIT;
END;
/

--사원번호를 일련번호로 재생성
UPDATE bigemp
SET employee_id = rownum;

-- 대부분의 데이터를 'department_id = 50'으로 변경 (약 20만 건)
UPDATE bigemp
SET    department_id = 50
WHERE  ROWNUM <= 200000;

--극소수의 데이터를 'department_id = 10'으로 변경 (3건)
UPDATE bigemp
SET    department_id = 10
WHERE  department_id = 50
AND    ROWNUM <= 3;

COMMIT;

2. /*+ INDEX(e EMP_EMAIL_IX) */
옵티마이저에게 employees 테이블에서 EMP_EMAIL_IX 인덱스를 사용하도록 지시하는 힌트입니다. email 컬럼에 조건이 있으므로 해당 인덱스를 사용하면 빠르게 탐색할 수 있습니다. 인덱스를 명시적으로 지정해 실행계획을 유도합니다.

CREATE INDEX bigemp_email_ix ON bigemp(email);
EXPLAIN PLAN FOR
SELECT /*+ INDEX(e EMP_EMAIL_IX) */
       e.first_name, e.email
FROM   bigemp e
WHERE  e.email = 'SKING';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


2. /*+ USE_NL(e d) */
옵티마이저에게 employees와 departments 테이블 간의 조인을 Nested Loops 방식으로 수행하라고 지시하는 힌트입니다. 
드라이빙 테이블의 결과 수가 적고, 조인 조건 컬럼에 인덱스가 있다면 효율적인 조인 방식이 될 수 있습니다.

EXPLAIN PLAN FOR
SELECT /*+ USE_NL(e d) */
       e.employee_id, e.first_name, d.department_name
FROM   bigemp e
JOIN   departments d
ON     e.department_id = d.department_id;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


3. /*+ FULL(e) */
옵티마이저에게 employees 테이블에 대해 인덱스를 무시하고 Full Table Scan을 수행하도록 지시하는 힌트입니다. 조건에 해당하는 레코드가 많거나 인덱스 사용이 오히려 비효율적인 경우 유리합니다.

CREATE INDEX bigemp_deptid_ix ON bigemp(department_id);
EXPLAIN PLAN FOR
SELECT /*+ FULL(e) */
       e.employee_id, e.department_id 
FROM   bigemp e
WHERE  e.department_id > 40;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


4. 옵티마이저 모드 관련 힌트

--옵티마이저에게 전체 쿼리 처리의 효율성을 극대화하는 실행계획을 선택하라고 지시합니다. 대용량 데이터를 배치 처리하거나 전체 결과를 빠르게 생성하는 것이 중요할 때 유리합니다. 

EXPLAIN PLAN FOR
SELECT /*+ ALL_ROWS */
       e.employee_id, e.salary, e.department_id
FROM   bigemp e
WHERE  e.department_id = 50;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


-- 처음 n개의 행을 가장 빠르게 반환하는 실행계획을 선택하라는 지시입니다. 인터랙티브한 애플리케이션에서 사용자에게 빠른 응답을 제공하고자 할 때 유용하며, 옵티마이저는 빠른 접근 경로를 우선 고려합니다.
EXPLAIN PLAN FOR
SELECT /*+ FIRST_ROWS(10) */
       e.employee_id, e.first_name
FROM   bigemp e
WHERE  e.department_id = 50;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);


5. 인덱스를 삭제하여 실습을 정리합니다.
DROP INDEX bigemp_email_ix ;
DROP INDEX bigemp_deptid_ix ;